// This class connects to the WS server and listens for incoming messages.

export class BconsWS
{
  // Below are the class properties that you can customize.
  // Just pass the constructor an object with the properties you want to set.

  // The user token is mandatory for identifying yourself as that user on the
  // bcons server and to receive messages.
  userToken = "";
  // The bcons websocket server. He's the delivery guy, so we call him Fry.
  wsServer = "wss://bcons.dev/fry";
  // The device that launched this console. The web extension uses "BE" and the
  // bcons website "BWC". You can put whatever you want here, this is used to
  // let you know which devices are currently connected to the bcons server.
  device = "custom";
  // Functions to call for logging info and error messages. Pass some functions
  // here to get any messages generated by the console code. By default
  // messages are logged to the console.
  errLog = null;
  msgLog = null;
  // This function is called when a message is received, with a single
  // parameter: the message
  onMessage = null;

  // The rest of the properties are meant to be for internal use only.

  // The websocket connection to the bcons server
  ws = null;
  // How many times have we tried to reconnect on a dirty closed connection
  reconnectCount = 0;
  // The id of the timer used for reconnecting
  reconnectTimerId = null;
  // The current bcons server we are connecting to.
  currentWsServer = "wss://bcons.dev/fry";


  constructor(options)
  {
    // Overwrite default options
    [
      "userToken", "wsServer", "device", "onMessage", "msgLog", "errLog"
    ].forEach(key =>
    {
      if (typeof options[key] !== "undefined")
      {
        this[key] = options[key];
      }
    });

    this.currentWsServer = this.wsServer;
  }

  // Connect to Fry
  connect()
  {
    // A user token is mandatory
    if (!this.userToken)
    {
      this.logErr("User token required for BconsWS init");
      return;
    }

    // We also need a server to connect to
    if (!this.currentWsServer)
    {
      this.logErr("No Fry server provided, aborting.");
      return;
    }

    this.log("Connecting to Fry");

    // Only connect if not connecting (0), open (1) or closing (2)
    if (this.ws && this.ws.readyState != 3)
    {
      this.log("Websocket readyState is", this.ws.readyState, ". Aborting");
      return;
    }

    this.log("WS creation", this.currentWsServer);
    this.ws = new WebSocket(this.currentWsServer);

    this.ws.onopen = () => {
      this.log("[ws] Connection established");
      this.reconnectCount = 0;
      this.ws.send(`{"e": "auth", "userToken":"${this.userToken}", "device":"${this.device}"}`);
    };

    this.ws.onclose = e => {
      if (e.wasClean)
      {
        this.log("WS connection closed clean");
        this.log(e);
        if (e.code == 302)
        {
          this.currentWsServer = e.reason;
          this.log("Forwarding to", this.currentWsServer);
          this.connect();
        }

        if (e.code > 400 && e.code < 500)
        {
          const content = { errorCode: e.code, reason: e.reason };
          if (this.onMessage)
            setTimeout(() => this.onMessage(content), 3000);
        }
      }
      else
      {
        // Server closed dirty, try to reconnect
        this.log(
          "Disconnected, will try to reconnect. Retry count:",
          this.reconnectCount
        );

        let retry = 1000;
        ++this.reconnectCount;

        // Increase reconnection time to avoid ddosing the server
        if (this.reconnectCount > 20)
          retry = 10000;
        else if (this.reconnectCount > 10)
          retry = 7000;
        else if (this.reconnectCount > 5)
          retry = 5000;

        // After 5 retries switch to the server provided in the constructor.
        // This allows the load balancer to redirect us to a live server.
        if (this.reconnectCount > 5 && this.currentWsServer != this.wsServer)
        {
          this.log("Switching to", this.wsServer);
          this.currentWsServer = this.wsServer;
          retry = 1000;
        }

        if (this.reconnectTimerId)
          clearTimeout(this.reconnectTimerId);
        this.reconnectTimerId = setTimeout(() => this.connect(), retry);
      }
    };

    this.ws.onerror = error => {
      this.logErr(`[ws]`, error);
    };

    this.ws.onmessage = msg => {
      try
      {
        const data = JSON.parse(msg.data);

        // Call the provided callback
        if (this.onMessage)
          this.onMessage(data);
      }
      catch (e) {this.logErr(e);}
    };
  }

  // Sends a message to Fry
  send(message)
  {
    // We can only send if socket is open
    if (this.ws.readyState != 1)
      return;

    if (typeof message != "string")
      message = JSON.stringify(message);

    this.ws.send(message);
  }

  // Disconnect from Fry
  disconnect(callback = null)
  {
    this.log(("Closing WS"));
    if (this.ws)
      this.ws.close();
  }

  // Logs a message to the provided callback or the console
  log(...params)
  {
    if (this.msgLog)
      this.msgLog(...params);
    else console.log(...params);
  }

  // Logs a message to the provided callback or the console
  logErr(...params)
  {
    if (this.errLog)
      this.errLog(...params);
    else console.error(...params);
  }
}
